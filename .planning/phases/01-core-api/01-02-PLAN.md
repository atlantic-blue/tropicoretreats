---
phase: 01-core-api
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - infra/api/main.tf
  - infra/api/lambda.tf
  - infra/api/dynamodb.tf
  - infra/api/iam.tf
  - infra/api/variables.tf
  - infra/api/outputs.tf
autonomous: true

must_haves:
  truths:
    - "POST /leads endpoint accepts JSON and returns 201/400/500"
    - "Valid submissions are stored in DynamoDB with ULID and status=NEW"
    - "CORS headers allow marketing site origin"
    - "Dev environment is deployed with -dev suffix resources"
  artifacts:
    - path: "infra/api/main.tf"
      provides: "API Gateway HTTP API with CORS configuration"
      contains: "aws_apigatewayv2_api"
    - path: "infra/api/lambda.tf"
      provides: "Lambda function with ARM64 and Node.js 22.x"
      contains: "aws_lambda_function"
    - path: "infra/api/dynamodb.tf"
      provides: "DynamoDB table with GSI for status queries"
      contains: "aws_dynamodb_table"
    - path: "infra/api/iam.tf"
      provides: "IAM role with DynamoDB and CloudWatch permissions"
      contains: "aws_iam_role"
    - path: "infra/api/variables.tf"
      provides: "Environment variable for dev/prod switching"
      contains: "variable \"environment\""
    - path: "infra/api/outputs.tf"
      provides: "API endpoint URL output"
      contains: "output \"api_endpoint\""
  key_links:
    - from: "infra/api/main.tf"
      to: "infra/api/lambda.tf"
      via: "API Gateway integration to Lambda"
      pattern: "aws_lambda_function\\.create_lead\\.invoke_arn"
    - from: "infra/api/lambda.tf"
      to: "infra/api/dynamodb.tf"
      via: "TABLE_NAME environment variable"
      pattern: "TABLE_NAME.*aws_dynamodb_table\\.leads\\.name"
    - from: "infra/api/lambda.tf"
      to: "infra/api/iam.tf"
      via: "Lambda execution role"
      pattern: "role.*aws_iam_role\\.lambda\\.arn"
---

<objective>
Create the Terraform infrastructure for the Core API: API Gateway HTTP API, Lambda function, and DynamoDB table.

Purpose: This deploys the serverless infrastructure that receives contact form submissions at POST /leads, invokes the Lambda handler, and persists leads to DynamoDB. The dev environment uses -dev suffixed resources.

Output: Terraform configuration in `infra/api/` that can be deployed with `terraform apply` to create a working POST /leads endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-api/01-RESEARCH.md
@.planning/phases/01-core-api/01-01-SUMMARY.md
@infra/_vars.tf
@infra/_locals.tf
@infra/_providers.tf
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DynamoDB table and IAM resources</name>
  <files>
    infra/api/variables.tf
    infra/api/dynamodb.tf
    infra/api/iam.tf
  </files>
  <action>
Create the foundational infrastructure resources:

1. Create `infra/api/variables.tf`:
   - Reference existing variables from parent module (environment, product_name, aws_region)
   - Add variable for CORS allowed origins with default for dev (localhost + production domain)

2. Create `infra/api/dynamodb.tf`:
   ```hcl
   resource "aws_dynamodb_table" "leads" {
     name         = "tropico-leads-${var.environment}"
     billing_mode = "PAY_PER_REQUEST"
     hash_key     = "PK"
     range_key    = "SK"

     attribute {
       name = "PK"
       type = "S"
     }

     attribute {
       name = "SK"
       type = "S"
     }

     attribute {
       name = "GSI1PK"
       type = "S"
     }

     attribute {
       name = "GSI1SK"
       type = "S"
     }

     global_secondary_index {
       name            = "GSI1"
       hash_key        = "GSI1PK"
       range_key       = "GSI1SK"
       projection_type = "ALL"
     }

     tags = local.tags
   }
   ```
   - GSI1 enables queries by status (GSI1PK) sorted by createdAt (GSI1SK)

3. Create `infra/api/iam.tf`:
   - Create aws_iam_role "lambda" with assume role policy for lambda.amazonaws.com
   - Create aws_iam_role_policy "lambda_dynamodb" allowing:
     - dynamodb:PutItem, GetItem, Query on leads table
     - dynamodb:Query on GSI1 index
   - Create aws_iam_role_policy "lambda_logs" allowing:
     - logs:CreateLogGroup, CreateLogStream, PutLogEvents
   - Use data.aws_caller_identity for account ID in ARN construction
  </action>
  <verify>
    Run: `cd /Users/juliantellez/github.com/atlantic-blue/tropicoretreats/infra && terraform fmt -check api/`
    Expected: Terraform files are properly formatted (or format them if not)
  </verify>
  <done>infra/api/dynamodb.tf and iam.tf exist with valid Terraform syntax</done>
</task>

<task type="auto">
  <name>Task 2: Create Lambda function and API Gateway</name>
  <files>
    infra/api/lambda.tf
    infra/api/main.tf
    infra/api/outputs.tf
  </files>
  <action>
Create the Lambda and API Gateway resources:

1. Create `infra/api/lambda.tf`:
   ```hcl
   data "archive_file" "lambda" {
     type        = "zip"
     source_file = "${path.module}/../../backend/dist/index.js"
     output_path = "${path.module}/../../backend/dist/lambda.zip"
   }

   resource "aws_cloudwatch_log_group" "lambda" {
     name              = "/aws/lambda/tropico-create-lead-${var.environment}"
     retention_in_days = 14
     tags              = local.tags
   }

   resource "aws_lambda_function" "create_lead" {
     filename         = data.archive_file.lambda.output_path
     function_name    = "tropico-create-lead-${var.environment}"
     role             = aws_iam_role.lambda.arn
     handler          = "index.handler"
     source_code_hash = data.archive_file.lambda.output_base64sha256
     runtime          = "nodejs22.x"
     architectures    = ["arm64"]
     memory_size      = 256
     timeout          = 30

     environment {
       variables = {
         TABLE_NAME  = aws_dynamodb_table.leads.name
         ENVIRONMENT = var.environment
       }
     }

     depends_on = [aws_cloudwatch_log_group.lambda]
     tags       = local.tags
   }

   resource "aws_lambda_permission" "api" {
     statement_id  = "AllowAPIGateway"
     action        = "lambda:InvokeFunction"
     function_name = aws_lambda_function.create_lead.function_name
     principal     = "apigateway.amazonaws.com"
     source_arn    = "${aws_apigatewayv2_api.leads.execution_arn}/*/*"
   }
   ```

2. Create `infra/api/main.tf`:
   ```hcl
   locals {
     tags = {
       product     = var.product_name
       environment = var.environment
       gitRepo     = "github.com/atlantic-blue/tropicoretreat"
       managed_by  = "terraform"
     }

     cors_origins = var.environment == "production"
       ? ["https://tropicoretreat.com", "https://www.tropicoretreat.com"]
       : ["http://localhost:3000", "http://localhost:5173", "https://tropicoretreat.com", "https://www.tropicoretreat.com"]
   }

   resource "aws_cloudwatch_log_group" "api" {
     name              = "/aws/apigateway/tropico-leads-api-${var.environment}"
     retention_in_days = 14
     tags              = local.tags
   }

   resource "aws_apigatewayv2_api" "leads" {
     name          = "tropico-leads-api-${var.environment}"
     protocol_type = "HTTP"

     cors_configuration {
       allow_origins = local.cors_origins
       allow_methods = ["POST", "OPTIONS"]
       allow_headers = ["Content-Type", "Authorization"]
       max_age       = 3600
     }

     tags = local.tags
   }

   resource "aws_apigatewayv2_stage" "default" {
     api_id      = aws_apigatewayv2_api.leads.id
     name        = "$default"
     auto_deploy = true

     access_log_settings {
       destination_arn = aws_cloudwatch_log_group.api.arn
       format = jsonencode({
         requestId      = "$context.requestId"
         ip             = "$context.identity.sourceIp"
         requestTime    = "$context.requestTime"
         httpMethod     = "$context.httpMethod"
         routeKey       = "$context.routeKey"
         status         = "$context.status"
         responseLength = "$context.responseLength"
         errorMessage   = "$context.error.message"
       })
     }

     tags = local.tags
   }

   resource "aws_apigatewayv2_integration" "create_lead" {
     api_id             = aws_apigatewayv2_api.leads.id
     integration_type   = "AWS_PROXY"
     integration_method = "POST"
     integration_uri    = aws_lambda_function.create_lead.invoke_arn
     payload_format_version = "2.0"
   }

   resource "aws_apigatewayv2_route" "create_lead" {
     api_id    = aws_apigatewayv2_api.leads.id
     route_key = "POST /leads"
     target    = "integrations/${aws_apigatewayv2_integration.create_lead.id}"
   }
   ```

3. Create `infra/api/outputs.tf`:
   ```hcl
   output "api_endpoint" {
     description = "API Gateway endpoint URL"
     value       = aws_apigatewayv2_api.leads.api_endpoint
   }

   output "api_id" {
     description = "API Gateway ID"
     value       = aws_apigatewayv2_api.leads.id
   }

   output "lambda_function_name" {
     description = "Lambda function name"
     value       = aws_lambda_function.create_lead.function_name
   }

   output "dynamodb_table_name" {
     description = "DynamoDB table name"
     value       = aws_dynamodb_table.leads.name
   }
   ```
  </action>
  <verify>
    Run: `cd /Users/juliantellez/github.com/atlantic-blue/tropicoretreats/infra && terraform fmt api/ && terraform validate`
    Expected: Terraform validation passes
  </verify>
  <done>infra/api/lambda.tf, main.tf, outputs.tf exist with valid Terraform configuration</done>
</task>

<task type="auto">
  <name>Task 3: Deploy dev environment and verify endpoint</name>
  <files>
    (Terraform state - no new files)
  </files>
  <action>
Deploy the infrastructure to AWS and verify the endpoint works:

1. Initialize Terraform for the api module:
   ```bash
   cd infra
   terraform init
   ```

2. Plan the deployment to verify configuration:
   ```bash
   terraform plan -target=module.api
   ```
   Note: If api is not a module, run `terraform plan` and verify api resources are included.

   Actually, since api/ is a subdirectory with its own resources but shares the root state, we need to ensure the root main.tf includes the api resources or reference them properly.

   CORRECTION: The infra/api/ directory should be referenced from infra/main.tf. Check if main.tf needs updating to include the api module, or if resources should be in the root.

   Given the existing structure (infra/*.tf files in root), add the api resources directly or use a module pattern:

   Option A (recommended): Add module reference to infra/main.tf:
   ```hcl
   module "api" {
     source = "./api"

     environment  = var.environment
     product_name = var.product_name
     aws_region   = var.aws_region
   }
   ```

   Then run:
   ```bash
   terraform init
   terraform plan
   terraform apply -auto-approve
   ```

3. After deployment, test the endpoint:
   ```bash
   # Get the API endpoint from Terraform output
   API_URL=$(terraform output -raw module.api.api_endpoint)

   # Test with valid payload
   curl -X POST "${API_URL}/leads" \
     -H "Content-Type: application/json" \
     -d '{
       "firstName": "Test",
       "lastName": "User",
       "email": "test@example.com",
       "message": "This is a test submission from terraform deployment verification"
     }'

   # Expected: {"id":"01HXYZ...","message":"Lead created successfully"}

   # Test with invalid payload (missing required field)
   curl -X POST "${API_URL}/leads" \
     -H "Content-Type: application/json" \
     -d '{"firstName": "Test"}'

   # Expected: {"error":"Validation failed","details":{...}}
   ```

4. Verify lead was stored in DynamoDB:
   ```bash
   aws dynamodb scan --table-name tropico-leads-dev --profile atlantic-blue
   ```
  </action>
  <verify>
    Run: `curl -s -X POST "$(cd /Users/juliantellez/github.com/atlantic-blue/tropicoretreats/infra && terraform output -raw api_endpoint 2>/dev/null || echo 'API_ENDPOINT_HERE')/leads" -H "Content-Type: application/json" -d '{"firstName":"Test","lastName":"User","email":"test@example.com","message":"Verification test"}'`
    Expected: HTTP 201 with JSON response containing id field
  </verify>
  <done>Dev environment deployed, POST /leads returns 201 for valid data and 400 for invalid data</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Terraform resources created:
   - API Gateway HTTP API: tropico-leads-api-dev (or production)
   - Lambda function: tropico-create-lead-dev
   - DynamoDB table: tropico-leads-dev
   - IAM role with proper permissions
   - CloudWatch log groups for API and Lambda

2. API endpoint test:
   ```bash
   # Valid submission returns 201
   curl -X POST "${API_URL}/leads" \
     -H "Content-Type: application/json" \
     -d '{"firstName":"John","lastName":"Doe","email":"john@example.com","message":"Test"}' \
     -w "\nHTTP Status: %{http_code}\n"

   # Invalid submission returns 400
   curl -X POST "${API_URL}/leads" \
     -H "Content-Type: application/json" \
     -d '{"firstName":"John"}' \
     -w "\nHTTP Status: %{http_code}\n"
   ```

3. CORS headers present:
   ```bash
   curl -I -X OPTIONS "${API_URL}/leads" \
     -H "Origin: http://localhost:3000" \
     -H "Access-Control-Request-Method: POST"
   # Should include Access-Control-Allow-Origin header
   ```

4. DynamoDB contains test lead:
   ```bash
   aws dynamodb scan --table-name tropico-leads-dev --profile atlantic-blue
   ```
</verification>

<success_criteria>
1. POST /leads endpoint accepts JSON payload (firstName, lastName, email, phone, company, groupSize, preferredDates, destination, message)
2. Valid submissions stored in DynamoDB with ULID, timestamp, status=NEW
3. Invalid submissions return 400 with validation errors
4. API returns CORS headers for marketing site origin (and localhost in dev)
5. Dev environment deployed with -dev suffix on all resources
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-api/01-02-SUMMARY.md`
</output>
