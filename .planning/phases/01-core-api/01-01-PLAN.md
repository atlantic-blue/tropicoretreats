---
phase: 01-core-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/package.json
  - backend/tsconfig.json
  - backend/esbuild.config.js
  - backend/src/handlers/createLead.ts
  - backend/src/lib/dynamodb.ts
  - backend/src/lib/validation.ts
  - backend/src/lib/types.ts
  - backend/src/utils/response.ts
autonomous: true

must_haves:
  truths:
    - "Lambda handler validates input with Zod schema"
    - "Valid input creates lead with ULID and persists to DynamoDB"
    - "Invalid input returns 400 with field-level errors"
    - "Handler exports function compatible with API Gateway HTTP API v2"
  artifacts:
    - path: "backend/src/handlers/createLead.ts"
      provides: "POST /leads Lambda handler"
      exports: ["handler"]
    - path: "backend/src/lib/validation.ts"
      provides: "Zod schema matching contact form fields"
      exports: ["LeadSchema", "LeadInput"]
    - path: "backend/src/lib/types.ts"
      provides: "Lead entity type with DynamoDB keys"
      exports: ["Lead"]
    - path: "backend/src/lib/dynamodb.ts"
      provides: "DynamoDB Document Client singleton"
      exports: ["docClient", "putLead"]
    - path: "backend/src/utils/response.ts"
      provides: "HTTP response helpers"
      exports: ["created", "badRequest", "serverError"]
    - path: "backend/package.json"
      provides: "Dependencies and build script"
      contains: "\"build\":"
    - path: "backend/dist/index.js"
      provides: "Bundled Lambda deployment artifact"
      min_lines: 1
  key_links:
    - from: "backend/src/handlers/createLead.ts"
      to: "backend/src/lib/validation.ts"
      via: "import LeadSchema"
      pattern: "import.*LeadSchema.*from.*validation"
    - from: "backend/src/handlers/createLead.ts"
      to: "backend/src/lib/dynamodb.ts"
      via: "putLead function call"
      pattern: "putLead\\("
    - from: "backend/package.json"
      to: "backend/dist/index.js"
      via: "esbuild build script"
      pattern: "\"build\".*esbuild"
---

<objective>
Create the Lambda handler code for the POST /leads endpoint that validates contact form submissions and persists leads to DynamoDB.

Purpose: This is the core business logic that receives form data, validates it against the contact form schema, generates a ULID for the lead, and stores it in DynamoDB with status=NEW.

Output: A fully functional Lambda handler with TypeScript source code and bundled deployment artifact in `backend/dist/`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-api/01-RESEARCH.md
@frontend/src/pages/ContactPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize backend project with dependencies</name>
  <files>
    backend/package.json
    backend/tsconfig.json
    backend/esbuild.config.js
  </files>
  <action>
Create the backend project structure with proper tooling:

1. Create `backend/package.json` with:
   - name: "tropico-leads-api"
   - type: "module" (ESM)
   - scripts:
     - "build": "node esbuild.config.js"
     - "clean": "rm -rf dist"
   - dependencies:
     - @aws-sdk/client-dynamodb: ^3.700.0
     - @aws-sdk/lib-dynamodb: ^3.700.0
     - zod: ^3.24.0
     - ulidx: ^2.4.0
   - devDependencies:
     - @types/aws-lambda: ^8.10.145
     - @types/node: ^22.0.0
     - esbuild: ^0.24.0
     - typescript: ^5.7.0

2. Create `backend/tsconfig.json` with:
   - target: "ES2022"
   - module: "NodeNext"
   - moduleResolution: "NodeNext"
   - strict: true
   - outDir: "dist"
   - rootDir: "src"
   - esModuleInterop: true
   - skipLibCheck: true

3. Create `backend/esbuild.config.js` with:
   - entryPoints: ['src/handlers/createLead.ts']
   - bundle: true
   - minify: true
   - sourcemap: true
   - platform: 'node'
   - target: 'node22'
   - outfile: 'dist/index.js'
   - format: 'esm' (for Node.js 22 ESM support)
   - external: ['@aws-sdk/*'] (SDK is pre-installed in Lambda runtime)
   - banner: { js: "import { createRequire } from 'module'; const require = createRequire(import.meta.url);" } (for ESM compatibility)

Run `npm install` in backend directory after creating files.
  </action>
  <verify>
    Run: `cd /Users/juliantellez/github.com/atlantic-blue/tropicoretreats/backend && npm install && ls node_modules/@aws-sdk`
    Expected: node_modules exists with @aws-sdk packages installed
  </verify>
  <done>backend/package.json, tsconfig.json, esbuild.config.js exist and npm install succeeds</done>
</task>

<task type="auto">
  <name>Task 2: Create Lambda handler with validation and DynamoDB persistence</name>
  <files>
    backend/src/lib/types.ts
    backend/src/lib/validation.ts
    backend/src/lib/dynamodb.ts
    backend/src/utils/response.ts
    backend/src/handlers/createLead.ts
  </files>
  <action>
Create the Lambda handler code with proper structure:

1. Create `backend/src/lib/types.ts`:
   ```typescript
   export interface Lead {
     PK: string;           // "LEAD#01HXYZ..."
     SK: string;           // "LEAD#01HXYZ..."
     GSI1PK: string;       // "STATUS#NEW"
     GSI1SK: string;       // ISO 8601 createdAt
     id: string;           // ULID
     status: 'NEW' | 'CONTACTED' | 'QUOTED' | 'WON' | 'LOST';
     firstName: string;
     lastName: string;
     email: string;
     phone?: string;
     company?: string;
     groupSize?: string;
     preferredDates?: string;
     destination?: string;
     message: string;
     createdAt: string;
     updatedAt: string;
   }
   ```

2. Create `backend/src/lib/validation.ts`:
   - Import z from 'zod'
   - Define LeadSchema with fields matching ContactPage.tsx:
     - firstName: z.string().min(1).max(100)
     - lastName: z.string().min(1).max(100)
     - email: z.string().email()
     - phone: z.string().max(50).optional()
     - company: z.string().max(200).optional()
     - groupSize: z.string().max(20).optional()
     - preferredDates: z.string().max(100).optional()
     - destination: z.string().max(50).optional()
     - message: z.string().min(1).max(5000)
   - Export LeadInput type: z.infer<typeof LeadSchema>

3. Create `backend/src/lib/dynamodb.ts`:
   - Import DynamoDBClient from @aws-sdk/client-dynamodb
   - Import DynamoDBDocumentClient, PutCommand from @aws-sdk/lib-dynamodb
   - Create client singleton OUTSIDE handler (for warm starts)
   - Get TABLE_NAME from process.env.TABLE_NAME
   - Export putLead(lead: Lead): Promise<void> function using PutCommand

4. Create `backend/src/utils/response.ts`:
   - Import APIGatewayProxyResultV2 from aws-lambda
   - Export created(data: unknown) -> 201 response
   - Export badRequest(error: string, details?: unknown) -> 400 response
   - Export serverError(message?: string) -> 500 response
   - All responses return JSON body (no CORS headers - handled by API Gateway)

5. Create `backend/src/handlers/createLead.ts`:
   - Import APIGatewayProxyEventV2, APIGatewayProxyResultV2 from aws-lambda
   - Import ulid from ulidx
   - Import LeadSchema, LeadInput from lib/validation
   - Import Lead from lib/types
   - Import putLead from lib/dynamodb
   - Import created, badRequest, serverError from utils/response
   - Export async handler function:
     a. Parse event.body as JSON (handle undefined/invalid JSON)
     b. Validate with LeadSchema.safeParse(body)
     c. If validation fails: return badRequest with fieldErrors
     d. Generate ULID, create Lead object with:
        - PK: `LEAD#${id}`
        - SK: `LEAD#${id}`
        - GSI1PK: 'STATUS#NEW'
        - GSI1SK: createdAt (ISO 8601)
        - status: 'NEW'
        - createdAt/updatedAt: new Date().toISOString()
     e. Call putLead(lead)
     f. Return created({ id, message: 'Lead created successfully' })
     g. Wrap in try/catch, return serverError on exception
  </action>
  <verify>
    Run: `cd /Users/juliantellez/github.com/atlantic-blue/tropicoretreats/backend && npx tsc --noEmit`
    Expected: TypeScript compiles without errors
  </verify>
  <done>All source files exist, TypeScript compiles without errors</done>
</task>

<task type="auto">
  <name>Task 3: Build Lambda deployment artifact</name>
  <files>
    backend/dist/index.js
    backend/dist/index.js.map
  </files>
  <action>
Build the Lambda handler using esbuild:

1. Run `npm run build` in backend directory
2. Verify dist/index.js is created and bundled (should be ~10-50KB minified)
3. Verify dist/index.js.map exists for debugging
4. Check bundle does NOT include @aws-sdk (should be external)

The build script in esbuild.config.js handles:
- TypeScript compilation
- Bundling all dependencies except @aws-sdk
- Minification for smaller cold starts
- Source maps for error tracking
  </action>
  <verify>
    Run: `cd /Users/juliantellez/github.com/atlantic-blue/tropicoretreats/backend && npm run build && ls -la dist/ && head -c 500 dist/index.js`
    Expected: dist/index.js exists, is minified, does not contain @aws-sdk imports inline
  </verify>
  <done>backend/dist/index.js exists and is properly bundled for Lambda deployment</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Directory structure check:
   ```
   backend/
     package.json
     package-lock.json
     tsconfig.json
     esbuild.config.js
     node_modules/
     src/
       handlers/createLead.ts
       lib/types.ts
       lib/validation.ts
       lib/dynamodb.ts
       utils/response.ts
     dist/
       index.js
       index.js.map
   ```

2. TypeScript compilation: `npx tsc --noEmit` passes

3. Build output: `dist/index.js` is bundled and minified

4. Handler exports: `dist/index.js` exports a `handler` function
</verification>

<success_criteria>
1. All source files created with correct TypeScript code
2. TypeScript compiles without errors (`npx tsc --noEmit`)
3. esbuild produces `dist/index.js` deployment artifact
4. Validation schema matches ContactPage.tsx form fields
5. Handler follows AWS Lambda best practices (SDK client outside handler)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-api/01-01-SUMMARY.md`
</output>
