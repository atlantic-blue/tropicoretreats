---
phase: 05-admin-dashboard
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - infra/api/lambda.tf
  - infra/api/iam.tf
  - infra/api/main.tf
  - infra/api/outputs.tf
autonomous: true

must_haves:
  truths:
    - "leadsAdmin Lambda is deployed"
    - "users Lambda is deployed"
    - "GET /leads route is protected by JWT authorizer"
    - "GET /leads/{id} route exists and is protected"
    - "PATCH /leads/{id} route exists and is protected"
    - "POST /leads/{id}/notes route exists and is protected"
    - "PATCH /leads/{id}/notes/{noteId} route exists and is protected"
    - "GET /users route exists and is protected"
  artifacts:
    - path: "infra/api/lambda.tf"
      provides: "leadsAdmin and users Lambda function definitions"
      contains: "aws_lambda_function.*leads_admin"
    - path: "infra/api/main.tf"
      provides: "API Gateway routes for admin endpoints"
      contains: "PATCH /leads/\\{id\\}"
  key_links:
    - from: "infra/api/main.tf"
      to: "infra/api/lambda.tf"
      via: "Lambda integrations reference function ARNs"
      pattern: "aws_lambda_function\\.leads_admin\\.invoke_arn"
---

<objective>
Deploy Terraform infrastructure for admin API endpoints

Purpose: Create Lambda functions for leadsAdmin and users handlers, wire them to API Gateway routes with JWT authorization. All admin endpoints must be protected by the Cognito JWT authorizer created in Phase 4.

Output: Deployed Lambda functions and API Gateway routes for GET /leads, GET /leads/{id}, PATCH /leads/{id}, notes endpoints, GET /users
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-admin-dashboard/05-02-SUMMARY.md

# Current Terraform structure
@infra/api/lambda.tf
@infra/api/main.tf
@infra/api/iam.tf
@infra/api/cognito.tf
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Lambda functions for admin handlers</name>
  <files>infra/api/lambda.tf, infra/api/iam.tf</files>
  <action>
Add Lambda function definitions following the existing pattern from create_lead.

1. In lambda.tf, add leadsAdmin Lambda:
```hcl
resource "aws_lambda_function" "leads_admin" {
  function_name = "tropico-leads-admin-${var.environment}"
  role          = aws_iam_role.lambda.arn
  handler       = "leadsAdmin.handler"
  runtime       = "nodejs22.x"
  timeout       = 30
  memory_size   = 256

  filename         = "${path.module}/../../backend/dist/leadsAdmin.zip"
  source_code_hash = filebase64sha256("${path.module}/../../backend/dist/leadsAdmin.zip")

  environment {
    variables = {
      TABLE_NAME     = aws_dynamodb_table.leads.name
      ENVIRONMENT    = var.environment
    }
  }

  tags = local.tags
}
```

2. Add users Lambda:
```hcl
resource "aws_lambda_function" "users" {
  function_name = "tropico-users-${var.environment}"
  role          = aws_iam_role.lambda.arn
  handler       = "users.handler"
  runtime       = "nodejs22.x"
  timeout       = 10
  memory_size   = 128

  filename         = "${path.module}/../../backend/dist/users.zip"
  source_code_hash = filebase64sha256("${path.module}/../../backend/dist/users.zip")

  environment {
    variables = {
      USER_POOL_ID = aws_cognito_user_pool.admin.id
      ENVIRONMENT  = var.environment
    }
  }

  tags = local.tags
}
```

3. In iam.tf, add Cognito ListUsers permission to Lambda role:
```hcl
# Add to existing policy or create new policy
resource "aws_iam_role_policy" "lambda_cognito" {
  name   = "tropico-lambda-cognito-${var.environment}"
  role   = aws_iam_role.lambda.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect   = "Allow"
        Action   = ["cognito-idp:ListUsers"]
        Resource = aws_cognito_user_pool.admin.arn
      }
    ]
  })
}
```

4. Add Lambda permissions for API Gateway invocation:
```hcl
resource "aws_lambda_permission" "leads_admin" {
  statement_id  = "AllowAPIGateway"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.leads_admin.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_apigatewayv2_api.leads.execution_arn}/*/*"
}

resource "aws_lambda_permission" "users" {
  statement_id  = "AllowAPIGateway"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.users.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_apigatewayv2_api.leads.execution_arn}/*/*"
}
```

Note: The build script must create .zip files. Update backend package.json build script or add zip step.
  </action>
  <verify>`cd infra && terraform validate` passes</verify>
  <done>Lambda functions leads_admin and users defined with appropriate IAM permissions</done>
</task>

<task type="auto">
  <name>Task 2: Add API Gateway routes and integrations</name>
  <files>infra/api/main.tf</files>
  <action>
Add API Gateway integrations and routes for admin endpoints.

1. Add leadsAdmin integration (single integration for multiple routes):
```hcl
resource "aws_apigatewayv2_integration" "leads_admin" {
  api_id                 = aws_apigatewayv2_api.leads.id
  integration_type       = "AWS_PROXY"
  integration_method     = "POST"
  integration_uri        = aws_lambda_function.leads_admin.invoke_arn
  payload_format_version = "2.0"
}
```

2. Add users integration:
```hcl
resource "aws_apigatewayv2_integration" "users" {
  api_id                 = aws_apigatewayv2_api.leads.id
  integration_type       = "AWS_PROXY"
  integration_method     = "POST"
  integration_uri        = aws_lambda_function.users.invoke_arn
  payload_format_version = "2.0"
}
```

3. Update existing GET /leads route to use leads_admin handler (remove or replace the stub):
```hcl
# Remove or update the existing get_leads route that pointed to create_lead
resource "aws_apigatewayv2_route" "get_leads" {
  api_id             = aws_apigatewayv2_api.leads.id
  route_key          = "GET /leads"
  target             = "integrations/${aws_apigatewayv2_integration.leads_admin.id}"
  authorization_type = "JWT"
  authorizer_id      = aws_apigatewayv2_authorizer.cognito.id
}
```

4. Add new routes (all protected by JWT authorizer):
```hcl
resource "aws_apigatewayv2_route" "get_lead" {
  api_id             = aws_apigatewayv2_api.leads.id
  route_key          = "GET /leads/{id}"
  target             = "integrations/${aws_apigatewayv2_integration.leads_admin.id}"
  authorization_type = "JWT"
  authorizer_id      = aws_apigatewayv2_authorizer.cognito.id
}

resource "aws_apigatewayv2_route" "patch_lead" {
  api_id             = aws_apigatewayv2_api.leads.id
  route_key          = "PATCH /leads/{id}"
  target             = "integrations/${aws_apigatewayv2_integration.leads_admin.id}"
  authorization_type = "JWT"
  authorizer_id      = aws_apigatewayv2_authorizer.cognito.id
}

resource "aws_apigatewayv2_route" "create_note" {
  api_id             = aws_apigatewayv2_api.leads.id
  route_key          = "POST /leads/{id}/notes"
  target             = "integrations/${aws_apigatewayv2_integration.leads_admin.id}"
  authorization_type = "JWT"
  authorizer_id      = aws_apigatewayv2_authorizer.cognito.id
}

resource "aws_apigatewayv2_route" "patch_note" {
  api_id             = aws_apigatewayv2_api.leads.id
  route_key          = "PATCH /leads/{id}/notes/{noteId}"
  target             = "integrations/${aws_apigatewayv2_integration.leads_admin.id}"
  authorization_type = "JWT"
  authorizer_id      = aws_apigatewayv2_authorizer.cognito.id
}

resource "aws_apigatewayv2_route" "get_users" {
  api_id             = aws_apigatewayv2_api.leads.id
  route_key          = "GET /users"
  target             = "integrations/${aws_apigatewayv2_integration.users.id}"
  authorization_type = "JWT"
  authorizer_id      = aws_apigatewayv2_authorizer.cognito.id
}
```

5. Update CORS allow_methods to include PATCH:
```hcl
cors_configuration {
  allow_methods = ["GET", "POST", "PATCH", "OPTIONS"]
  # ... rest unchanged
}
```
  </action>
  <verify>`cd infra && terraform validate` passes</verify>
  <done>API Gateway routes exist for all admin endpoints with JWT authorization</done>
</task>

<task type="auto">
  <name>Task 3: Build, zip, and deploy</name>
  <files>backend/package.json</files>
  <action>
1. Update backend package.json build script to create zip files:
```json
"scripts": {
  "build": "node esbuild.config.mjs && npm run zip",
  "zip": "cd dist && for f in *.mjs; do zip \"${f%.mjs}.zip\" \"$f\"; done",
  ...
}
```

Or use a more portable approach:
```json
"scripts": {
  "build": "node esbuild.config.mjs",
  "zip": "node -e \"const fs=require('fs');const {execSync}=require('child_process');const files=fs.readdirSync('dist').filter(f=>f.endsWith('.mjs'));files.forEach(f=>execSync('cd dist && zip '+f.replace('.mjs','.zip')+' '+f))\"",
  "deploy": "npm run build && npm run zip"
}
```

2. Run `cd backend && npm run deploy` to build and zip

3. Deploy Terraform:
```bash
cd infra
terraform plan -var="environment=production"
terraform apply -var="environment=production" -auto-approve
```

4. Verify deployment:
- Lambda functions exist and have correct handlers
- API routes exist
- All routes show JWT authorization
  </action>
  <verify>
- `cd infra && terraform apply` completes successfully
- `aws lambda get-function --function-name tropico-leads-admin-production` returns function info
- `aws lambda get-function --function-name tropico-users-production` returns function info
- `aws apigatewayv2 get-routes --api-id <api-id>` shows all routes with JWT auth
  </verify>
  <done>Lambda functions deployed; API routes active with JWT authorization</done>
</task>

</tasks>

<verification>
All checks:
1. `terraform apply` completed without errors
2. Lambda functions exist:
   - tropico-leads-admin-production
   - tropico-users-production
3. API Gateway routes exist with JWT authorization:
   - GET /leads
   - GET /leads/{id}
   - PATCH /leads/{id}
   - POST /leads/{id}/notes
   - PATCH /leads/{id}/notes/{noteId}
   - GET /users
4. Test with curl (using JWT from Phase 4):
   - `curl -H "Authorization: Bearer $TOKEN" https://api.../leads` returns 200 (or 400 if no leads)
   - `curl https://api.../leads` returns 401
</verification>

<success_criteria>
1. terraform apply succeeds
2. Both Lambda functions deployed and invocable
3. All 6 admin routes exist and require JWT
4. Authenticated request to GET /leads returns 200
5. Unauthenticated request returns 401
</success_criteria>

<output>
After completion, create `.planning/phases/05-admin-dashboard/05-03-SUMMARY.md`
</output>
