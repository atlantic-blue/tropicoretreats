---
phase: 05-admin-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/src/handlers/leadsAdmin.ts
  - backend/src/handlers/users.ts
  - backend/esbuild.config.mjs
autonomous: true

must_haves:
  truths:
    - "GET /leads returns paginated lead list with filters"
    - "GET /leads/{id} returns single lead with all fields"
    - "PATCH /leads/{id} updates lead fields with status progression validation"
    - "POST /leads/{id}/notes creates a note"
    - "PATCH /leads/{id}/notes/{noteId} updates a note"
    - "GET /users returns list of Cognito users"
  artifacts:
    - path: "backend/src/handlers/leadsAdmin.ts"
      provides: "Lambda handler for admin lead operations"
      exports: ["handler"]
    - path: "backend/src/handlers/users.ts"
      provides: "Lambda handler for listing Cognito users"
      exports: ["handler"]
    - path: "backend/esbuild.config.mjs"
      provides: "Build config for new handlers"
      contains: "leadsAdmin|users"
  key_links:
    - from: "backend/src/handlers/leadsAdmin.ts"
      to: "backend/src/lib/dynamodb.ts"
      via: "imports getLeads, getLead, updateLead, getNotes, putNote, updateNote"
      pattern: "import.*getLeads.*getLead.*from.*dynamodb"
    - from: "backend/src/handlers/leadsAdmin.ts"
      to: "backend/src/lib/validation.ts"
      via: "imports validation schemas"
      pattern: "import.*LeadUpdateSchema.*NoteCreateSchema.*from.*validation"
---

<objective>
Create Lambda handlers for admin dashboard API endpoints

Purpose: The admin dashboard needs API endpoints for listing leads, viewing lead details, updating leads (status, temperature, assignee), managing notes, and listing Cognito users for the assignee dropdown. This plan creates the Lambda handlers that will be wired to API Gateway in Plan 03.

Output: leadsAdmin.ts handler (GET/PATCH leads, notes operations), users.ts handler (list Cognito users)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-admin-dashboard/05-CONTEXT.md
@.planning/phases/05-admin-dashboard/05-RESEARCH.md
@.planning/phases/05-admin-dashboard/05-01-SUMMARY.md

# Current handler pattern
@backend/src/handlers/createLead.ts
@backend/src/utils/response.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create leadsAdmin Lambda handler</name>
  <files>backend/src/handlers/leadsAdmin.ts</files>
  <action>
Create a multi-route Lambda handler for admin lead operations. The handler inspects the HTTP method and path to route to the correct operation.

Use the existing handler pattern from createLead.ts. Import from:
- `../lib/dynamodb.js` - getLeads, getLead, updateLead, getNotes, putNote, updateNote
- `../lib/validation.js` - LeadUpdateSchema, NoteCreateSchema, NoteUpdateSchema, validateStatusProgression
- `../utils/response.js` - created, ok, badRequest, serverError, notFound
- `../lib/types.js` - Lead, Note, Temperature
- `ulidx` - ulid for note IDs

Add `notFound` and `ok` helpers to response.ts if not present:
```typescript
export const notFound = (message = 'Not found') => ({
  statusCode: 404,
  body: JSON.stringify({ error: message }),
});
export const ok = (data: unknown) => ({
  statusCode: 200,
  body: JSON.stringify(data),
});
```

Handler routes:

1. **GET /leads** - List leads with pagination/filters
   - Parse query params: status[], temperature[], assigneeId, limit, page (convert to lastKey)
   - Call getLeads with params
   - Return { leads, nextPage, totalCount }

2. **GET /leads/{id}** - Get lead details with notes
   - Extract id from pathParameters
   - Call getLead(id)
   - If null, return 404
   - Call getNotes(id)
   - Return { ...lead, notes }

3. **PATCH /leads/{id}** - Update lead
   - Extract id from pathParameters
   - Parse and validate body with LeadUpdateSchema
   - Get current lead (for status progression validation)
   - If status changed, validate with validateStatusProgression
   - Call updateLead(id, validatedData)
   - If status/temperature/assignee changed, create SYSTEM note:
     - "{authorName} changed {field} to {value}"
   - Return updated lead

4. **POST /leads/{id}/notes** - Add note
   - Extract leadId from pathParameters
   - Validate body with NoteCreateSchema
   - Extract authorId from JWT claims (event.requestContext.authorizer.jwt.claims.sub)
   - Extract authorName from JWT claims (event.requestContext.authorizer.jwt.claims.email or username)
   - Create Note with ULID, type=MANUAL
   - Call putNote(note)
   - Return 201 with note

5. **PATCH /leads/{id}/notes/{noteId}** - Edit note
   - Extract leadId, noteId from pathParameters
   - Validate body with NoteUpdateSchema
   - Call updateNote(leadId, noteId, content)
   - Return updated note

Default: Return 405 Method Not Allowed

Export handler function.
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>leadsAdmin.ts handler routes GET /leads, GET /leads/{id}, PATCH /leads/{id}, POST/PATCH notes</done>
</task>

<task type="auto">
  <name>Task 2: Create users Lambda handler</name>
  <files>backend/src/handlers/users.ts</files>
  <action>
Create a Lambda handler to list Cognito users for the assignee dropdown.

Use @aws-sdk/client-cognito-identity-provider:
```typescript
import { CognitoIdentityProviderClient, ListUsersCommand } from '@aws-sdk/client-cognito-identity-provider';
```

Note: This SDK is NOT pre-installed in Lambda runtime, so it must be bundled (unlike @aws-sdk/client-dynamodb which is external). Update package.json dependencies in Task 3.

Handler:
```typescript
const cognitoClient = new CognitoIdentityProviderClient({});
const USER_POOL_ID = process.env.USER_POOL_ID;

export const handler = async (event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> => {
  // Only respond to GET /users
  if (event.requestContext.http.method !== 'GET') {
    return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
  }

  try {
    const response = await cognitoClient.send(new ListUsersCommand({
      UserPoolId: USER_POOL_ID,
      Limit: 60, // Max users for dropdown
    }));

    const users = (response.Users || []).map(user => ({
      id: user.Attributes?.find(a => a.Name === 'sub')?.Value,
      email: user.Attributes?.find(a => a.Name === 'email')?.Value,
      username: user.Username,
      status: user.UserStatus,
    })).filter(u => u.id && u.status === 'CONFIRMED');

    return ok({ users });
  } catch (error) {
    console.error('Error listing users:', error);
    return serverError();
  }
};
```

Export handler function.
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>users.ts handler returns list of Cognito users with id, email, username</done>
</task>

<task type="auto">
  <name>Task 3: Update esbuild config and package.json</name>
  <files>backend/esbuild.config.mjs, backend/package.json</files>
  <action>
1. Read current esbuild.config.mjs and add entry points for new handlers:
   - `src/handlers/leadsAdmin.ts` -> `dist/leadsAdmin.mjs`
   - `src/handlers/users.ts` -> `dist/users.mjs`

2. Add @aws-sdk/client-cognito-identity-provider to package.json dependencies:
```json
"dependencies": {
  "@aws-sdk/client-cognito-identity-provider": "^3.x",
  // ... existing deps
}
```

Note: Unlike DynamoDB/SES clients which are external (pre-installed in Lambda), the Cognito Identity Provider client must be bundled.

3. In esbuild config, keep @aws-sdk/client-dynamodb and @aws-sdk/lib-dynamodb as external, but do NOT mark @aws-sdk/client-cognito-identity-provider as external (it will be bundled).

Alternatively, mark ALL @aws-sdk/* as external since Node 22 Lambda includes them. Check Lambda docs - if included, mark as external.

4. Run `npm install` to install new dependency
5. Run `npm run build` to verify build succeeds
  </action>
  <verify>
- `cd backend && npm install` succeeds
- `cd backend && npm run build` produces dist/leadsAdmin.mjs and dist/users.mjs
- Both files are under 500KB
  </verify>
  <done>esbuild builds leadsAdmin.mjs and users.mjs; package.json has cognito SDK dependency</done>
</task>

</tasks>

<verification>
All checks:
1. `cd backend && npx tsc --noEmit` passes
2. `cd backend && npm run build` produces:
   - dist/createLead.mjs
   - dist/processLeadNotifications.mjs
   - dist/leadsAdmin.mjs
   - dist/users.mjs
3. leadsAdmin.ts handles GET /leads, GET /leads/{id}, PATCH /leads/{id}, POST/PATCH notes
4. users.ts handles GET /users
</verification>

<success_criteria>
1. leadsAdmin.ts exports handler with 5 route handlers
2. users.ts exports handler that lists Cognito users
3. Build produces dist/leadsAdmin.mjs and dist/users.mjs
4. All handlers use consistent error handling and response patterns
5. JWT claims are used to get author info for notes
</success_criteria>

<output>
After completion, create `.planning/phases/05-admin-dashboard/05-02-SUMMARY.md`
</output>
