---
phase: 05-admin-dashboard
plan: 06
type: execute
wave: 5
depends_on: ["05-03", "05-04"]
files_modified:
  - admin/src/types/lead.ts
  - admin/src/api/client.ts
  - admin/src/api/leads.ts
  - admin/src/hooks/useLeads.ts
  - admin/src/hooks/useFilters.ts
  - admin/src/components/ui/Badge.tsx
  - admin/src/components/ui/Pagination.tsx
  - admin/src/components/leads/LeadCard.tsx
  - admin/src/components/leads/LeadGrid.tsx
  - admin/src/components/leads/LeadFilters.tsx
  - admin/src/pages/LeadsListPage.tsx
autonomous: true

must_haves:
  truths:
    - "Lead list page shows cards in responsive grid"
    - "Cards show name, status badge, temperature icon, relative timestamp"
    - "Filters persist in URL"
    - "Pagination works"
    - "Search debounces before querying"
    - "Clicking card navigates to lead detail"
  artifacts:
    - path: "admin/src/pages/LeadsListPage.tsx"
      provides: "Lead list page with filters and grid"
      contains: "LeadGrid"
    - path: "admin/src/components/leads/LeadCard.tsx"
      provides: "Lead card component"
      contains: "Flame"
    - path: "admin/src/hooks/useFilters.ts"
      provides: "URL-based filter state"
      contains: "useSearchParams"
  key_links:
    - from: "admin/src/pages/LeadsListPage.tsx"
      to: "admin/src/hooks/useLeads.ts"
      via: "uses useLeads hook"
      pattern: "useLeads"
    - from: "admin/src/hooks/useLeads.ts"
      to: "admin/src/api/leads.ts"
      via: "calls API functions"
      pattern: "import.*leadsApi.*from.*api/leads"
---

<objective>
Build lead list page with card grid, filters, search, and pagination

Purpose: Admins need to see all leads at a glance with ability to filter by status, temperature, assignee, and date range. Per CONTEXT.md: cards grid layout (3 per row), minimal card content (name, status badge, temperature icon, timestamp), horizontal filter bar, URL-persisted filters, pagination (15 per page).

Output: Fully functional lead list page connected to the API deployed in Plan 03
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-admin-dashboard/05-CONTEXT.md
@.planning/phases/05-admin-dashboard/05-RESEARCH.md
@.planning/phases/05-admin-dashboard/05-03-SUMMARY.md
@.planning/phases/05-admin-dashboard/05-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types and API client</name>
  <files>admin/src/types/lead.ts, admin/src/api/client.ts, admin/src/api/leads.ts</files>
  <action>
1. Create src/types/lead.ts with frontend types:
```typescript
export type LeadStatus = 'NEW' | 'CONTACTED' | 'QUOTED' | 'WON' | 'LOST';
export type Temperature = 'HOT' | 'WARM' | 'COLD';
export type NoteType = 'MANUAL' | 'SYSTEM';

export interface Lead {
  id: string;
  status: LeadStatus;
  temperature: Temperature;
  firstName: string;
  lastName: string;
  email: string;
  phone?: string;
  company?: string;
  groupSize?: string;
  preferredDates?: string;
  destination?: string;
  message: string;
  assigneeId?: string;
  assigneeName?: string;
  createdAt: string;
  updatedAt: string;
}

export interface Note {
  id: string;
  leadId: string;
  content: string;
  authorId: string;
  authorName: string;
  type: NoteType;
  createdAt: string;
  updatedAt: string;
}

export interface LeadWithNotes extends Lead {
  notes: Note[];
}

export interface LeadsResponse {
  leads: Lead[];
  nextPage?: number;
  totalCount: number;
}

export interface User {
  id: string;
  email: string;
  username: string;
}
```

2. Create src/api/client.ts - fetch wrapper with auth:
```typescript
import { useAuth } from '../hooks/useAuth';

const API_BASE = import.meta.env.VITE_API_ENDPOINT;

// Singleton for token getter (set by App.tsx)
let getTokenFn: () => Promise<string>;

export function setTokenGetter(fn: () => Promise<string>) {
  getTokenFn = fn;
}

export async function fetchWithAuth<T>(path: string, options: RequestInit = {}): Promise<T> {
  if (!getTokenFn) throw new Error('Token getter not initialized');

  const token = await getTokenFn();
  const response = await fetch(`${API_BASE}${path}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,
      ...options.headers,
    },
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ message: 'Request failed' }));
    throw new Error(error.message || `API error: ${response.status}`);
  }

  return response.json();
}
```

3. Create src/api/leads.ts:
```typescript
import { fetchWithAuth } from './client';
import type { Lead, LeadWithNotes, LeadsResponse, Note, User } from '../types/lead';

export interface FilterParams {
  status?: string[];
  temperature?: string[];
  assignee?: string;
  search?: string;
  from?: string;
  to?: string;
  page?: number;
  limit?: number;
}

export const leadsApi = {
  list: (params: FilterParams): Promise<LeadsResponse> => {
    const searchParams = new URLSearchParams();
    if (params.status?.length) params.status.forEach(s => searchParams.append('status', s));
    if (params.temperature?.length) params.temperature.forEach(t => searchParams.append('temperature', t));
    if (params.assignee) searchParams.set('assignee', params.assignee);
    if (params.search) searchParams.set('search', params.search);
    if (params.from) searchParams.set('from', params.from);
    if (params.to) searchParams.set('to', params.to);
    if (params.page) searchParams.set('page', String(params.page));
    if (params.limit) searchParams.set('limit', String(params.limit));
    return fetchWithAuth<LeadsResponse>(`/leads?${searchParams.toString()}`);
  },

  get: (id: string): Promise<LeadWithNotes> =>
    fetchWithAuth<LeadWithNotes>(`/leads/${id}`),

  update: (id: string, data: Partial<Lead>): Promise<Lead> =>
    fetchWithAuth<Lead>(`/leads/${id}`, { method: 'PATCH', body: JSON.stringify(data) }),

  addNote: (leadId: string, content: string): Promise<Note> =>
    fetchWithAuth<Note>(`/leads/${leadId}/notes`, { method: 'POST', body: JSON.stringify({ content }) }),

  updateNote: (leadId: string, noteId: string, content: string): Promise<Note> =>
    fetchWithAuth<Note>(`/leads/${leadId}/notes/${noteId}`, { method: 'PATCH', body: JSON.stringify({ content }) }),
};

export const usersApi = {
  list: (): Promise<{ users: User[] }> =>
    fetchWithAuth<{ users: User[] }>('/users'),
};
```
  </action>
  <verify>TypeScript compiles: `cd admin && npx tsc --noEmit`</verify>
  <done>Lead types defined; API client with auth; leadsApi and usersApi functions</done>
</task>

<task type="auto">
  <name>Task 2: Create hooks for leads and filters</name>
  <files>admin/src/hooks/useLeads.ts, admin/src/hooks/useFilters.ts, admin/src/hooks/useDebouncedValue.ts</files>
  <action>
1. Create src/hooks/useDebouncedValue.ts:
```typescript
import { useState, useEffect } from 'react';

export function useDebouncedValue<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay);
    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
}
```

2. Create src/hooks/useFilters.ts (from 05-RESEARCH.md Pattern 2):
```typescript
import { useSearchParams } from 'react-router';

export interface Filters {
  search: string;
  status: string[];
  temperature: string[];
  assignee: string;
  dateFrom: string;
  dateTo: string;
  page: number;
}

export function useFilters() {
  const [searchParams, setSearchParams] = useSearchParams();

  const filters: Filters = {
    search: searchParams.get('search') || '',
    status: searchParams.getAll('status'),
    temperature: searchParams.getAll('temp'),
    assignee: searchParams.get('assignee') || '',
    dateFrom: searchParams.get('from') || '',
    dateTo: searchParams.get('to') || '',
    page: parseInt(searchParams.get('page') || '1', 10),
  };

  const setFilter = (key: string, value: string | string[]) => {
    const newParams = new URLSearchParams(searchParams);
    newParams.delete(key);
    if (Array.isArray(value)) {
      value.forEach(v => newParams.append(key, v));
    } else if (value) {
      newParams.set(key, value);
    }
    // Reset to page 1 when filter changes (except page itself)
    if (key !== 'page') newParams.set('page', '1');
    setSearchParams(newParams);
  };

  const setPage = (page: number) => setFilter('page', String(page));

  const clearFilters = () => setSearchParams({});

  const hasActiveFilters =
    filters.search || filters.status.length || filters.temperature.length ||
    filters.assignee || filters.dateFrom || filters.dateTo;

  return { filters, setFilter, setPage, clearFilters, hasActiveFilters };
}
```

3. Create src/hooks/useLeads.ts:
```typescript
import { useQuery, keepPreviousData } from '@tanstack/react-query';
import { leadsApi, FilterParams } from '../api/leads';
import { useDebouncedValue } from './useDebouncedValue';
import type { Filters } from './useFilters';

export function useLeads(filters: Filters) {
  const debouncedSearch = useDebouncedValue(filters.search, 300);

  const params: FilterParams = {
    search: debouncedSearch || undefined,
    status: filters.status.length ? filters.status : undefined,
    temperature: filters.temperature.length ? filters.temperature : undefined,
    assignee: filters.assignee || undefined,
    from: filters.dateFrom || undefined,
    to: filters.dateTo || undefined,
    page: filters.page,
    limit: 15,
  };

  return useQuery({
    queryKey: ['leads', params],
    queryFn: () => leadsApi.list(params),
    placeholderData: keepPreviousData,
  });
}

export function useUsers() {
  return useQuery({
    queryKey: ['users'],
    queryFn: () => usersApi.list().then(r => r.users),
    staleTime: 1000 * 60 * 30, // 30 minutes - users don't change often
  });
}
```
  </action>
  <verify>TypeScript compiles: `cd admin && npx tsc --noEmit`</verify>
  <done>useFilters provides URL-persisted filters; useLeads fetches with debounced search</done>
</task>

<task type="auto">
  <name>Task 3: Create UI components and lead list page</name>
  <files>admin/src/components/ui/Badge.tsx, admin/src/components/ui/Pagination.tsx, admin/src/components/leads/LeadCard.tsx, admin/src/components/leads/LeadGrid.tsx, admin/src/components/leads/LeadFilters.tsx, admin/src/pages/LeadsListPage.tsx</files>
  <action>
1. Create src/components/ui/Badge.tsx:
```typescript
interface BadgeProps {
  children: React.ReactNode;
  variant: 'blue' | 'yellow' | 'purple' | 'green' | 'gray';
}

const variants = {
  blue: 'bg-blue-100 text-blue-800',
  yellow: 'bg-yellow-100 text-yellow-800',
  purple: 'bg-purple-100 text-purple-800',
  green: 'bg-green-100 text-green-800',
  gray: 'bg-gray-100 text-gray-800',
};

export function Badge({ children, variant }: BadgeProps) {
  return (
    <span className={`inline-flex px-2 py-1 text-xs font-medium rounded ${variants[variant]}`}>
      {children}
    </span>
  );
}
```

2. Create src/components/ui/Pagination.tsx:
- Page numbers 1, 2, 3... with current highlighted
- Previous/Next buttons
- "Showing X of Y leads" text

3. Create src/components/leads/LeadCard.tsx (from 05-RESEARCH.md code example):
- Card with left border color by status
- Name, status badge, temperature flame icon (lucide-react), relative timestamp
- Whole card is Link to /leads/{id}
- Subtle shadow, hover effect

4. Create src/components/leads/LeadGrid.tsx:
```typescript
export function LeadGrid({ leads }: { leads: Lead[] }) {
  if (!leads.length) {
    return (
      <div className="text-center py-12">
        <p className="text-gray-500">No leads found</p>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {leads.map(lead => <LeadCard key={lead.id} lead={lead} />)}
    </div>
  );
}
```

5. Create src/components/leads/LeadFilters.tsx:
- Horizontal bar with: search input, status multi-select, temperature multi-select, assignee dropdown, date range picker (react-day-picker)
- Clear filters button if any active
- Uses useFilters hook

6. Create src/pages/LeadsListPage.tsx:
```typescript
export function LeadsListPage() {
  const { filters, setFilter, setPage, clearFilters, hasActiveFilters } = useFilters();
  const { data, isLoading, isError, error, isFetching, isPlaceholderData } = useLeads(filters);

  if (isLoading) return <LoadingSkeleton />;
  if (isError) return <ErrorMessage error={error} />;

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Leads</h1>
        <span className="text-sm text-gray-500">
          Showing {data.leads.length} of {data.totalCount} leads
        </span>
      </div>

      <LeadFilters />

      <LeadGrid leads={data.leads} />

      <Pagination
        currentPage={filters.page}
        totalPages={Math.ceil(data.totalCount / 15)}
        onPageChange={setPage}
        isLoading={isFetching && isPlaceholderData}
      />
    </div>
  );
}
```

7. Update App.tsx to use LeadsListPage instead of placeholder
  </action>
  <verify>
- `cd admin && npm run dev` shows lead list page
- Cards display with correct layout (3 columns on desktop)
- Filters appear in URL
- Pagination controls work
- Search debounces
  </verify>
  <done>Lead list page with cards, filters, pagination all working</done>
</task>

</tasks>

<verification>
All checks:
1. `cd admin && npm run dev` shows lead list page
2. Cards show name, status badge, temperature icon, relative time
3. 3-column grid on desktop, 1 column on mobile
4. URL updates when filters change
5. Refreshing page preserves filters from URL
6. Search waits 300ms before fetching
7. Clicking card navigates to /leads/{id}
8. Pagination shows correct total and navigates pages
</verification>

<success_criteria>
1. LeadCard shows all required info with status colors and temperature icon
2. LeadGrid uses responsive 3-column layout
3. LeadFilters has search, status, temperature, assignee, date range
4. Filters persist in URL (useSearchParams)
5. Search debounces 300ms
6. Pagination shows "Showing X of Y" and page controls
7. Empty state message when no leads
8. Loading state while fetching
</success_criteria>

<output>
After completion, create `.planning/phases/05-admin-dashboard/05-06-SUMMARY.md`
</output>
