---
phase: 05-admin-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/lib/types.ts
  - backend/src/lib/validation.ts
  - backend/src/lib/dynamodb.ts
autonomous: true

must_haves:
  truths:
    - "Lead entity includes temperature field"
    - "Lead entity includes assignee fields"
    - "Note entity type exists with all required fields"
    - "DynamoDB operations can query leads with filters"
    - "DynamoDB operations can CRUD notes"
  artifacts:
    - path: "backend/src/lib/types.ts"
      provides: "Lead, Note, Temperature types"
      contains: "temperature.*HOT.*WARM.*COLD"
    - path: "backend/src/lib/dynamodb.ts"
      provides: "getLeads, getLead, updateLead, putNote, getNotes, updateNote"
      exports: ["getLeads", "getLead", "updateLead", "putNote", "getNotes"]
  key_links:
    - from: "backend/src/lib/dynamodb.ts"
      to: "backend/src/lib/types.ts"
      via: "imports Lead, Note types"
      pattern: "import.*Lead.*Note.*from.*types"
---

<objective>
Extend backend types and DynamoDB operations for admin dashboard requirements

Purpose: The admin dashboard needs to read lead lists with filtering, update lead fields (status, temperature, assignee), and manage notes. Current backend only supports creating leads. This plan adds the type definitions and data access layer for all dashboard operations.

Output: Extended Lead type with temperature/assignee, new Note type, and DynamoDB query/update/notes operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-admin-dashboard/05-CONTEXT.md
@.planning/phases/05-admin-dashboard/05-RESEARCH.md

# Current backend types and operations
@backend/src/lib/types.ts
@backend/src/lib/dynamodb.ts
@backend/src/lib/validation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Lead type and add Note type</name>
  <files>backend/src/lib/types.ts</files>
  <action>
Extend the existing Lead interface and add Note type:

1. Add Temperature type: `'HOT' | 'WARM' | 'COLD'`
2. Add TemperatureEnum constant for type-safe handling (like LeadStatus)
3. Extend Lead interface with:
   - `temperature: Temperature` (required, default WARM for new leads)
   - `assigneeId?: string` (optional, Cognito user sub)
   - `assigneeName?: string` (optional, denormalized for display)

4. Add Note interface:
```typescript
interface Note {
  PK: string;           // LEAD#{leadId}
  SK: string;           // NOTE#{timestamp}#{noteId}
  id: string;           // ULID
  leadId: string;
  content: string;
  authorId: string;     // Cognito user sub
  authorName: string;   // Denormalized
  type: 'MANUAL' | 'SYSTEM';  // SYSTEM for auto-logged changes
  createdAt: string;
  updatedAt: string;
}
```

5. Add NoteType enum constant

Keep all existing types and exports intact.
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>Lead type includes temperature and assignee fields; Note type is defined with all required fields</done>
</task>

<task type="auto">
  <name>Task 2: Add Zod validation schemas for notes and lead updates</name>
  <files>backend/src/lib/validation.ts</files>
  <action>
Add validation schemas for dashboard operations:

1. Add NoteCreateSchema for POST /leads/{id}/notes:
```typescript
const NoteCreateSchema = z.object({
  content: z.string().min(1, 'Note content is required').max(5000),
});
```

2. Add NoteUpdateSchema for PATCH /leads/{id}/notes/{noteId}:
```typescript
const NoteUpdateSchema = z.object({
  content: z.string().min(1).max(5000),
});
```

3. Add LeadUpdateSchema for PATCH /leads/{id}:
```typescript
const LeadUpdateSchema = z.object({
  status: z.enum(['NEW', 'CONTACTED', 'QUOTED', 'WON', 'LOST']).optional(),
  temperature: z.enum(['HOT', 'WARM', 'COLD']).optional(),
  assigneeId: z.string().optional(),
  assigneeName: z.string().optional(),
}).refine(data => Object.keys(data).length > 0, {
  message: 'At least one field must be provided',
});
```

4. Add status progression validation (forward-only: NEW -> CONTACTED -> QUOTED -> WON/LOST):
```typescript
const STATUS_ORDER = { NEW: 0, CONTACTED: 1, QUOTED: 2, WON: 3, LOST: 3 };
function validateStatusProgression(currentStatus: string, newStatus: string): boolean {
  return STATUS_ORDER[newStatus] >= STATUS_ORDER[currentStatus];
}
```

Export all new schemas and the validation function.
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>NoteCreateSchema, NoteUpdateSchema, LeadUpdateSchema exported; validateStatusProgression function works</done>
</task>

<task type="auto">
  <name>Task 3: Add DynamoDB operations for leads and notes</name>
  <files>backend/src/lib/dynamodb.ts</files>
  <action>
Add DynamoDB operations using DocumentClient. Import required commands:
```typescript
import { QueryCommand, UpdateCommand, GetCommand } from '@aws-sdk/lib-dynamodb';
```

Add these functions:

1. **getLeads** - Query leads with optional filters and pagination:
```typescript
interface GetLeadsParams {
  status?: string[];      // Filter by status (multi-select)
  temperature?: string[]; // Filter by temperature (multi-select)
  assigneeId?: string;    // Filter by assignee
  limit?: number;         // Page size (default 15)
  lastKey?: string;       // Pagination cursor (base64 encoded)
}
interface GetLeadsResult {
  leads: Lead[];
  nextKey?: string;       // For next page
  count: number;          // Total matching (for "Showing X of Y")
}
```
Use GSI1 to query by status, or Scan with filters if no status filter.
NOTE: For MVP, scan is acceptable with small dataset. Production would need GSI per filter.

2. **getLead** - Get single lead by ID:
```typescript
async function getLead(id: string): Promise<Lead | null>
```
Query with PK=LEAD#{id}, SK=LEAD#{id}

3. **updateLead** - Partial update of lead fields:
```typescript
async function updateLead(id: string, updates: Partial<Lead>): Promise<Lead>
```
Use UpdateCommand with SET expression, auto-set updatedAt.
Also update GSI1PK if status changed.

4. **getNotes** - Get notes for a lead:
```typescript
async function getNotes(leadId: string): Promise<Note[]>
```
Query with PK=LEAD#{leadId}, SK begins_with NOTE#, sorted by SK descending (newest first)

5. **putNote** - Create a note:
```typescript
async function putNote(note: Note): Promise<void>
```
Same pattern as putLead

6. **updateNote** - Update note content:
```typescript
async function updateNote(leadId: string, noteId: string, content: string): Promise<Note>
```
UpdateCommand with condition that note exists

Export all new functions.
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>getLeads, getLead, updateLead, getNotes, putNote, updateNote functions exported and compile</done>
</task>

</tasks>

<verification>
All checks:
1. `cd backend && npx tsc --noEmit` passes
2. Lead type has temperature, assigneeId, assigneeName fields
3. Note type is exported with all required fields
4. All 6 DynamoDB functions are exported
5. Validation schemas for notes and lead updates are exported
</verification>

<success_criteria>
1. TypeScript compiles without errors
2. Lead type extended with temperature (required), assigneeId (optional), assigneeName (optional)
3. Note type defined with PK, SK, id, leadId, content, authorId, authorName, type, createdAt, updatedAt
4. DynamoDB operations: getLeads, getLead, updateLead, getNotes, putNote, updateNote
5. Validation: NoteCreateSchema, NoteUpdateSchema, LeadUpdateSchema, validateStatusProgression
</success_criteria>

<output>
After completion, create `.planning/phases/05-admin-dashboard/05-01-SUMMARY.md`
</output>
